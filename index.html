<!DOCTYPE html>
<html lang="pt-PT">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rastreador 3D da ISS (Visualiza√ß√£o Realista)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #000;
            color: #fff;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            /* Permite que o rato passe para o canvas 3D */
            z-index: 10;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 2rem;
            box-sizing: border-box;
            background: radial-gradient(circle at center, transparent 0%, rgba(0, 0, 0, 0.6) 100%);
        }

        .glass-panel {
            background: rgba(10, 20, 40, 0.75);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid rgba(0, 150, 255, 0.4);
            border-radius: 1rem;
            padding: 1.5rem;
            pointer-events: auto;
            /* Permite interagir com o painel */
            box-shadow: 0 4px 30px rgba(0, 150, 255, 0.2);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }

        .glass-panel:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 40px rgba(0, 150, 255, 0.3);
        }

        .stat-value {
            font-family: monospace;
            color: #00e5ff;
            font-size: 1.25rem;
            font-weight: bold;
            text-shadow: 0 0 10px rgba(0, 229, 255, 0.5);
        }

        #loading-screen {
            transition: opacity 0.5s ease-out;
        }

        /* Cursor ajustado pela OrbitControls automaticamente, mas podemos garantir */
        #canvas-container {
            cursor: grab;
        }

        #canvas-container:active {
            cursor: grabbing;
        }
    </style>
</head>

<body>

    <!-- Ecr√£ de Carregamento -->
    <div id="loading-screen"
        class="absolute inset-0 bg-black z-50 flex flex-col items-center justify-center text-white">
        <div class="w-16 h-16 border-4 border-blue-500 border-t-transparent rounded-full animate-spin mb-4"></div>
        <h2 class="text-2xl font-bold tracking-widest text-blue-400">A CARREGAR TEXTURAS 3D...</h2>
        <p class="text-gray-400 mt-2">Preparando texturas do planeta e da ISS</p>
    </div>

    <!-- Container do WebGL -->
    <div id="canvas-container"></div>

    <!-- Interface de Utilizador -->
    <div id="ui-layer">
        <div class="flex justify-between items-start">
            <div class="glass-panel w-80 max-w-full">
                <h1 class="text-2xl font-bold mb-1 flex items-center gap-3">
                    <span class="relative flex h-4 w-4">
                        <span
                            class="animate-ping absolute inline-flex h-full w-full rounded-full bg-red-400 opacity-75"></span>
                        <span class="relative inline-flex rounded-full h-4 w-4 bg-red-500"></span>
                    </span>
                    ISS Tracker Real 3D
                </h1>
                <p class="text-sm text-blue-300 mb-4 tracking-wide uppercase">Monitoriza√ß√£o em tempo real</p>

                <div class="space-y-3">
                    <div class="flex justify-between border-b mx-1 border-gray-700 pb-2">
                        <span class="text-gray-400 flex items-center gap-2"><svg class="w-4 h-4" fill="currentColor"
                                viewBox="0 0 24 24">
                                <path
                                    d="M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7zm0 9.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5z" />
                            </svg>Latitude:</span>
                        <span id="lat-display" class="stat-value">---</span>
                    </div>
                    <div class="flex justify-between border-b mx-1 border-gray-700 pb-2">
                        <span class="text-gray-400 flex items-center gap-2"><svg class="w-4 h-4" fill="currentColor"
                                viewBox="0 0 24 24">
                                <path
                                    d="M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7zm0 9.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5z" />
                            </svg>Longitude:</span>
                        <span id="lon-display" class="stat-value">---</span>
                    </div>
                    <div class="flex justify-between border-b mx-1 border-gray-700 pb-2">
                        <span class="text-gray-400 flex items-center gap-2"><svg class="w-4 h-4" fill="currentColor"
                                viewBox="0 0 24 24">
                                <path d="M16 13h-3V4c0-1.1-.9-2-2-2s-2 .9-2 2v9H6l5 5 5-5z" />
                            </svg>Altitude:</span>
                        <span id="alt-display" class="stat-value">---</span>
                    </div>
                    <div class="flex justify-between mx-1 pb-1">
                        <span class="text-gray-400 flex items-center gap-2"><svg class="w-4 h-4" fill="currentColor"
                                viewBox="0 0 24 24">
                                <path d="M13.5 1.5L9.5 9.5l4 1.5-8 11.5 4-8-4-1.5 8-11.5z" />
                            </svg>Velocidade:</span>
                        <span id="vel-display" class="stat-value">---</span>
                    </div>
                </div>
            </div>

            <div class="glass-panel text-sm text-gray-300 max-w-xs text-right hidden md:block">
                <p class="text-blue-400 font-bold mb-2">üåç Controlos da C√¢mara:</p>
                <div class="space-y-1">
                    <p>Clica e arrasta para rodar a cena.</p>
                    <p>Usa a roda do rato para zoom.</p>
                    <p>Bot√£o direito para arrastar o foco.</p>
                </div>
            </div>
        </div>

        <div
            class="text-center text-xs text-gray-400 glass-panel self-center w-auto py-2 px-6 pointer-events-none tracking-widest uppercase">
            Dados fornecidos por "Where the ISS at?" API
        </div>
    </div>

    <script>
        // Vari√°veis globais
        let scene, camera, renderer, controls;
        let earthGroup, earthMesh, cloudMesh, issMesh;
        let trailLine;

        let targetISSPosition = new THREE.Vector3();
        const EARTH_RADIUS = 5;

        // Trajet√≥ria rastro
        const TRAIL_LENGTH = 1500;
        let trailPositions = new Float32Array(TRAIL_LENGTH * 3);
        let trailCount = 0;

        window.onload = function () {
            init3D();
            startTracking();
            animate();
        };

        function init3D() {
            const container = document.getElementById('canvas-container');

            // 1. Configurar Cena
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000000, 0.015);

            // 2. Configurar C√¢mara
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 18;
            camera.position.y = 6;
            camera.lookAt(0, 0, 0);

            // 3. Configurar Renderizador
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true, powerPreference: "high-performance" });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            // Tom e propriedades f√≠sicas para melhor renderiza√ß√£o
            renderer.outputEncoding = THREE.sRGBEncoding;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            container.appendChild(renderer.domElement);

            // 4. OrbitControls
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.minDistance = 6;
            controls.maxDistance = 50;
            controls.autoRotate = true;     // Rota√ß√£o suave constante
            controls.autoRotateSpeed = 0.5;

            // 5. Grupo da Terra
            earthGroup = new THREE.Group();
            scene.add(earthGroup);

            // Loader com Gestor
            const manager = new THREE.LoadingManager();
            manager.onLoad = function () {
                const as = document.getElementById('loading-screen');
                as.style.opacity = '0';
                setTimeout(() => as.style.display = 'none', 500);
            };

            const textureLoader = new THREE.TextureLoader(manager);

            // Texturas Realistas da Terra (Alta Resolu√ß√£o do reposit√≥rio Three.js e similares)
            const earthMap = textureLoader.load('https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/planets/earth_atmos_2048.jpg');
            const earthSpecular = textureLoader.load('https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/planets/earth_specular_2048.jpg');
            const earthNormal = textureLoader.load('https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/planets/earth_normal_2048.jpg');
            const earthClouds = textureLoader.load('https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/planets/earth_clouds_1024.png');

            // Superf√≠cie da Terra com relevo e √°gua
            const earthGeo = new THREE.SphereGeometry(EARTH_RADIUS, 64, 64);
            const earthMat = new THREE.MeshPhongMaterial({
                map: earthMap,
                specularMap: earthSpecular,
                normalMap: earthNormal,
                shininess: 35,
                color: 0xffffff
            });
            earthMesh = new THREE.Mesh(earthGeo, earthMat);
            // Rota√ß√£o subtil para alinhar coordenadas de forma correta (Y rotation a -Math.PI/2 alinha Greenwhich com X=0, dependendo do mapeamento)
            earthMesh.rotation.y = -Math.PI / 2;
            earthGroup.add(earthMesh);

            // Camada de Nuvens
            const cloudGeo = new THREE.SphereGeometry(EARTH_RADIUS * 1.012, 64, 64);
            const cloudMat = new THREE.MeshPhongMaterial({
                map: earthClouds,
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending,
                side: THREE.DoubleSide,
                depthWrite: false
            });
            cloudMesh = new THREE.Mesh(cloudGeo, cloudMat);
            earthGroup.add(cloudMesh);

            // Atmosfera (Glow exterior) - Simulada com emiss√£o e opacidade baixa
            const atmosGeo = new THREE.SphereGeometry(EARTH_RADIUS * 1.15, 64, 64);
            const atmosMat = new THREE.MeshPhongMaterial({
                color: 0x1a73e8,
                transparent: true,
                opacity: 0.12,
                blending: THREE.AdditiveBlending,
                side: THREE.BackSide,
                depthWrite: false
            });
            const atmosphere = new THREE.Mesh(atmosGeo, atmosMat);
            earthGroup.add(atmosphere);

            // 6. Criar o modelo detalhado da ISS
            issMesh = createDetailedISS();
            // Sem rota√ß√£o de Y como placeholder
            issMesh.position.set(EARTH_RADIUS + 1, 0, 0);
            scene.add(issMesh); // Adicionamos √† scene e n√£o ao earthGroup, pois controlamos o target absoluto

            // Trajet√≥ria (Rastro)
            const trailGeometry = new THREE.BufferGeometry();
            // Inicializar posi√ß√µes nulas para n√£o desenhar do centro no in√≠cio
            for (let i = 0; i < TRAIL_LENGTH * 3; i++) trailPositions[i] = NaN;
            trailGeometry.setAttribute('position', new THREE.BufferAttribute(trailPositions, 3));
            const trailMaterial = new THREE.LineBasicMaterial({
                color: 0xff3366,
                linewidth: 2, // Nota: linewidth muitas vezes s√≥ suportado dependendo da plataforma WebGL (muitas vezes sempre ser√° 1)
                transparent: true,
                opacity: 0.6
            });
            trailLine = new THREE.Line(trailGeometry, trailMaterial);
            scene.add(trailLine);

            // 7. Ilumina√ß√£o (Sol forte, sombra profunda)
            const ambientLight = new THREE.AmbientLight(0x222233, 0.4);
            scene.add(ambientLight);

            const sunLight = new THREE.DirectionalLight(0xffffff, 1.8);
            sunLight.position.set(20, 10, 15);
            scene.add(sunLight);

            // Adicionar uma contra-luz azul fraca para simular luz do espa√ßo profundo/gal√°xia
            const backLight = new THREE.DirectionalLight(0x334455, 0.5);
            backLight.position.set(-20, -10, -15);
            scene.add(backLight);

            // 8. Fundo Estrelado (Part√≠culas)
            createStars();

            // Lidar com o redimensionamento da janela
            window.addEventListener('resize', onWindowResize, false);
        }

        function createDetailedISS() {
            const iss = new THREE.Group();

            const metalMat = new THREE.MeshStandardMaterial({ color: 0xe0e0e0, metalness: 0.9, roughness: 0.2 });
            const whiteMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.4 });

            // Textura dos Pain√©is Solares gerada no Canvas
            const canvas = document.createElement('canvas');
            canvas.width = 128; canvas.height = 128;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#112244'; ctx.fillRect(0, 0, 128, 128);
            ctx.strokeStyle = '#eebc1d'; ctx.lineWidth = 2; // Linhas douradas vis√≠veis
            for (let i = 0; i <= 128; i += 16) {
                ctx.beginPath(); ctx.moveTo(i, 0); ctx.lineTo(i, 128); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(0, i); ctx.lineTo(128, i); ctx.stroke();
            }
            const solarTex = new THREE.CanvasTexture(canvas);
            const solarMat = new THREE.MeshStandardMaterial({ map: solarTex, metalness: 0.6, roughness: 0.3, side: THREE.DoubleSide });

            // Truss Principal (Eixo X)
            const trussGeo = new THREE.CylinderGeometry(0.04, 0.04, 3.5, 8);
            const truss = new THREE.Mesh(trussGeo, metalMat);
            truss.rotation.z = Math.PI / 2;
            iss.add(truss);

            // M√≥dulos Centrais (Eixo Z em rela√ß√£o √† ISS)
            const coreGroup = new THREE.Group();
            coreGroup.rotation.x = Math.PI / 2;

            const mod1Geo = new THREE.CylinderGeometry(0.12, 0.12, 0.6, 16);
            const mod1 = new THREE.Mesh(mod1Geo, whiteMat);
            coreGroup.add(mod1);

            const mod2Geo = new THREE.CylinderGeometry(0.09, 0.09, 0.5, 16);
            const mod2 = new THREE.Mesh(mod2Geo, whiteMat);
            mod2.position.y = 0.55;
            coreGroup.add(mod2);

            const mod3Geo = new THREE.CylinderGeometry(0.1, 0.1, 0.4, 16);
            const mod3 = new THREE.Mesh(mod3Geo, whiteMat);
            mod3.position.y = -0.5;
            coreGroup.add(mod3);

            iss.add(coreGroup);

            // Pain√©is Solares (8 pares ao longo do Truss/Eixo X)
            const panelGeo = new THREE.BoxGeometry(0.4, 0.015, 1.2);
            const positions = [-1.5, -0.9, 0.9, 1.5];
            positions.forEach(x => {
                const p1 = new THREE.Mesh(panelGeo, solarMat);
                p1.position.set(x, 0.7, 0);
                const p2 = new THREE.Mesh(panelGeo, solarMat);
                p2.position.set(x, -0.7, 0);
                iss.add(p1);
                iss.add(p2);
            });

            // Radiadores (Paredes brancas perpendiculares)
            const radGeo = new THREE.BoxGeometry(0.03, 1.0, 0.5);
            const rad1 = new THREE.Mesh(radGeo, whiteMat);
            rad1.position.set(0, 0, 0.5);
            const rad2 = new THREE.Mesh(radGeo, whiteMat);
            rad2.position.set(0, 0, -0.5);
            iss.add(rad1);
            iss.add(rad2);

            iss.scale.set(0.15, 0.15, 0.15); // Tamanho ajustado ao planeta
            return iss;
        }

        function createStars() {
            const starGeometry = new THREE.BufferGeometry();
            const starCount = 4000;
            const posArray = new Float32Array(starCount * 3);

            for (let i = 0; i < starCount * 3; i++) {
                // Distribuir estrelas numa esfera gigante
                const r = 200 + Math.random() * 300;
                const theta = 2 * Math.PI * Math.random();
                const phi = Math.acos(2 * Math.random() - 1);

                posArray[i * 3 + 0] = r * Math.sin(phi) * Math.cos(theta); // x
                posArray[i * 3 + 1] = r * Math.sin(phi) * Math.sin(theta); // y
                posArray[i * 3 + 2] = r * Math.cos(phi);                   // z
            }

            starGeometry.setAttribute('position', new THREE.BufferAttribute(posArray, 3));

            // Textura circular para pontinhos de luz
            const canvas = document.createElement('canvas');
            canvas.width = 16; canvas.height = 16;
            const ctx = canvas.getContext('2d');
            const gradient = ctx.createRadialGradient(8, 8, 0, 8, 8, 8);
            gradient.addColorStop(0, 'rgba(255,255,255,1)');
            gradient.addColorStop(0.2, 'rgba(210,230,255,0.8)');
            gradient.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 16, 16);
            const starTex = new THREE.CanvasTexture(canvas);

            const starMaterial = new THREE.PointsMaterial({
                size: 1.5,
                map: starTex,
                color: 0xffffff,
                transparent: true,
                opacity: 0.9,
                depthWrite: false,
                blending: THREE.AdditiveBlending
            });

            const starParticles = new THREE.Points(starGeometry, starMaterial);
            scene.add(starParticles);
        }

        // --- L√≥gica de Dados da ISS ---
        async function fetchISSData() {
            try {
                const response = await fetch('https://api.wheretheiss.at/v1/satellites/25544');
                const data = await response.json();

                updateUI(data);
                updateISSPosition(data.latitude, data.longitude, data.altitude);

            } catch (error) {
                console.error("Erro ao obter dados da ISS:", error);
            }
        }

        function updateUI(data) {
            document.getElementById('lat-display').innerText = data.latitude.toFixed(4) + "¬∞";
            document.getElementById('lon-display').innerText = data.longitude.toFixed(4) + "¬∞";
            document.getElementById('alt-display').innerText = data.altitude.toFixed(1) + " km";
            document.getElementById('vel-display').innerText = data.velocity.toFixed(0) + " km/h";
        }

        let lastPositionForTrail = null;

        function updateISSPosition(lat, lon, altitudeKm) {
            // Converter a altitude real para a escala 3D
            const altitudeScale = (altitudeKm / 6371) * EARTH_RADIUS;
            const orbitRadius = EARTH_RADIUS + Math.max(0.4, altitudeScale);

            // Ajuste matem√°tico de Lat/Lon para a textura Real da Terra do MrDoob
            // Com earthMesh.rotation.y = -Math.PI / 2
            const phi = (90 - lat) * (Math.PI / 180);
            const theta = (lon + 180) * (Math.PI / 180);

            targetISSPosition.x = -(orbitRadius * Math.sin(phi) * Math.cos(theta));
            targetISSPosition.y = orbitRadius * Math.cos(phi);
            targetISSPosition.z = orbitRadius * Math.sin(phi) * Math.sin(theta);

            // Salvar para calcular o rastro (para evitar muitas atualiza√ß√µes irreais, podemos guardar a posi√ß√£o atual j√° processada)
        }

        function addTrailPoint(position) {
            const positions = trailLine.geometry.attributes.position.array;

            // Evitar zeros saltantes do MathNaN logo no inicio
            if (isNaN(positions[0])) {
                for (let i = 0; i < TRAIL_LENGTH; i++) {
                    positions[i * 3] = position.x;
                    positions[i * 3 + 1] = position.y;
                    positions[i * 3 + 2] = position.z;
                }
                trailCount = 1;
                trailLine.geometry.attributes.position.needsUpdate = true;
                return;
            }

            // Dist√¢ncia m√≠nima (para evitar duplicados no mesmo spot se a API responder repetido)
            const lastIdx = (trailCount - 1) % TRAIL_LENGTH;
            const dist = Math.hypot(
                positions[lastIdx * 3] - position.x,
                positions[lastIdx * 3 + 1] - position.y,
                positions[lastIdx * 3 + 2] - position.z
            );

            if (dist > 0.01) {
                const idx = trailCount % TRAIL_LENGTH;
                positions[idx * 3] = position.x;
                positions[idx * 3 + 1] = position.y;
                positions[idx * 3 + 2] = position.z;

                trailCount++;

                // Re-ordenar array ciclicamente se j√° passamos do limite, para desenhar apenas o array em sequ√™ncia l√≥gica
                // Sendo lineBasicMaterial a ordem √© fundamental. O ThreeJs Line usa a sequ√™ncia em que est√£o.
                // Como n√£o queremos fazer rec√°lculo de shift completo todos os frames:
                if (trailCount > TRAIL_LENGTH) {
                    const shiftPositions = new Float32Array(TRAIL_LENGTH * 3);
                    for (let i = 0; i < TRAIL_LENGTH; i++) {
                        const srcIdx = (trailCount - TRAIL_LENGTH + i) % TRAIL_LENGTH;
                        shiftPositions[i * 3] = positions[srcIdx * 3];
                        shiftPositions[i * 3 + 1] = positions[srcIdx * 3 + 1];
                        shiftPositions[i * 3 + 2] = positions[srcIdx * 3 + 2];
                    }
                    // Aplicar
                    trailLine.geometry.setAttribute('position', new THREE.BufferAttribute(shiftPositions, 3));
                    trailCount = TRAIL_LENGTH;
                } else {
                    trailLine.geometry.setDrawRange(0, trailCount);
                }

                trailLine.geometry.attributes.position.needsUpdate = true;
            }
        }

        function startTracking() {
            fetchISSData();
            // Atualizar a cada 2.5 segundos para fluidez
            setInterval(fetchISSData, 2500);
        }

        // --- Ciclo de Anima√ß√£o ---
        function animate() {
            requestAnimationFrame(animate);

            // OrbitControls atualiza in√©rcia e rota√ß√£o di√°ria auto
            if (controls) {
                controls.update();
            }

            // Mover a Nuvem subtilmente (Rota√ß√£o ligeira)
            if (cloudMesh) {
                cloudMesh.rotation.y += 0.0003;
            }

            // Interpolar a posi√ß√£o da ISS
            if (issMesh && targetISSPosition.length() > 0) {
                issMesh.position.lerp(targetISSPosition, 0.05);

                // Gravar rastro da posi√ß√£o smooth interpolada
                addTrailPoint(issMesh.position);

                // Fazer a ISS orientar com o eixo tangencial para ficar bonito ou virada para o plano do movimento
                // De forma simples de √≥rbita: apontar base para o solo √© .lookAt(centro) mas o topo aponta de e para fora. 
                // lookAt na verdade define o Z virado para o alvo (Terra) e o Y+ "para cima"
                issMesh.lookAt(0, 0, 0);
            }

            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
    </script>
</body>

</html>